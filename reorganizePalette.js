(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hslToRgb = hslToRgb;
exports.rgbToHsl = rgbToHsl;
// Generated by ChatGPT
function rgbToHsl(r, g, b) {
  // Normalize the RGB values
  r /= 255;
  g /= 255;
  b /= 255;

  // Find the maximum and minimum values among R, G, B
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);

  // Calculate the hue
  var h;
  if (max === min) {
    h = 0; // achromatic (gray)
  } else {
    var diff = max - min;
    switch (max) {
      case r:
        h = (g - b) / diff % 6;
        break;
      case g:
        h = (b - r) / diff + 2;
        break;
      case b:
        h = (r - g) / diff + 4;
        break;
    }
    h *= 60; // Convert to degrees
  }

  // Calculate the lightness
  var l = (max + min) / 2;

  // Calculate the saturation
  var s;
  if (max === min) {
    s = 0; // achromatic (gray)
  } else if (l <= 0.5) {
    s = diff / (2 * l);
  } else {
    s = diff / (2 - 2 * l);
  }

  // Round the values to two decimal places and return as an object
  return [Math.round(h), Math.round(s * 100), Math.round(l * 100)];
}

// Generated by ChatGPT
function hslToRgb(h, s, l) {
  // Convert degrees to 0-1 range
  h /= 360;
  s /= 100;
  l /= 100;
  var r, g, b;
  if (s === 0) {
    // Achromatic (gray)
    r = g = b = l;
  } else {
    var hue2rgb = function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  // Convert to 0-255 range
  r = Math.round(r * 255);
  g = Math.round(g * 255);
  b = Math.round(b * 255);
  return [r, g, b];
}

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rgbDistance = rgbDistance;
function rgbDistance(r, g, b, r2, g2, b2) {
  return Math.sqrt((r2 - r) ** 2 + (g2 - g) ** 2 + (b2 - b) ** 2);
}

},{}],3:[function(require,module,exports){
/* EDIT THE FOLLOWING LINES TO FIT YOUR NEEDS */
const PALETTE_ORDER = "P-";   // A LIST OF COLOR COMPONENTS WHICH CAN BE : 
// "H","S","L" from the HSL color space 
// "R","G","B" from the RGB color space
// "W" for whiteness (the sum of R, G and B)
// "P" for the number of pixels in the current image. 
// EACH COLOR COMPONENT MUST BE FOLLOWED BY A "+" OR "-" TO DETERMINE THE SORT ORDER (INCREASING OR DECREASING) ; YOU CAN PUT THE COMPONENT LETTERS IN ANY ORDER OR OMIT ANY OF THEM










const rgb = require ('./lib/rgb.mjs');
const hsl = require ('./lib/hsl.mjs');

const color = app.pixelColor;
const image = app.activeImage;
const palette = app.activeSprite.palette; 

const distanceFunction = rgb.rgbDistance;

const DEBUG = false;

const PALETTE = [];
for (var cIndex = 0 ; cIndex < palette.length; cIndex ++) {
    PALETTE [cIndex] = palette.get (cIndex);
}

const countCache = [];

if (PALETTE_ORDER.match ("P") !== null) {
    for (var x = 0; x < image.width; x ++) {
        for (var y = 0; y < image.height; y ++) {
            const p = image.getPixel (x, y);
            if (countCache [p] === undefined) {
                countCache [p] = 0;
            }
            else {
                countCache [p] ++;
            }
        }
    }
}

function countPixels (color1) {
    if (countCache [color1] !== undefined) {
        return countCache [color1];
    }
    else {
        return 0;
    }
}

function compareComponent (color1, color2, component) {
    var distance;
    switch (component.substring (0,1)) {
        case "P":
            distance = countPixels (color1) - countPixels (color2);
            break;
        case "W": 
            distance = color.rgbaR (color1) + color.rgbaG (color1) + color.rgbaB (color1) - color.rgbaR (color2) - color.rgbaG (color2) - color.rgbaB (color2) ;
            break;
        case "R": 
            distance = color.rgbaR (color1) - color.rgbaR (color2);
            break;
        case "G": 
            distance = color.rgbaG (color1) - color.rgbaG (color2);
            break;
        case "B": 
            distance = color.rgbaB (color1) - color.rgbaB (color2);
            break;
        case "A": 
            distance = color.rgbaA (color1) - color.rgbaA (color2);
            break;
        case "H": 
            distance = hsl.rgbToHsl (color.rgbaR (color1), color.rgbaG (color1), color.rgbaB (color1)) [0] - hsl.rgbToHsl (color.rgbaR (color2), color.rgbaG (color2), color.rgbaB (color2)) [0];
            break;
        case "S": 
            distance = hsl.rgbToHsl (color.rgbaR (color1), color.rgbaG (color1), color.rgbaB (color1)) [1] - hsl.rgbToHsl (color.rgbaR (color2), color.rgbaG (color2), color.rgbaB (color2)) [1];
            break;
        case "L": 
            distance = hsl.rgbToHsl (color.rgbaR (color1), color.rgbaG (color1), color.rgbaB (color1)) [2] - hsl.rgbToHsl (color.rgbaR (color2), color.rgbaG (color2), color.rgbaB (color2)) [2];
            break;
        default: 
            throw "Unknown pixel sorting component : " + component;
    }
    if (component.substring (1,2) === "-") distance = - distance;
    return distance;
}

function sort (paletteSlice, components) {
    if (components.length < 2) return;
    const component = components.substring (components.length - 2, components.length);
    PALETTE.splice (paletteSlice.begin, paletteSlice.end - paletteSlice.begin, ...PALETTE.slice (paletteSlice.begin, paletteSlice.end).sort ((p1, p2) => compareComponent (p1, p2, component)));
    var sliceBegin = paletteSlice.begin; 
    while (sliceBegin < paletteSlice.end) {
        var paletteColor = PALETTE [sliceBegin];
        var sliceEnd = sliceBegin + 1;
        while (sliceEnd < paletteSlice.end && compareComponent (PALETTE [sliceEnd], paletteColor, component)) {
            sliceEnd ++;
        }
        sort ({begin: sliceBegin, end: sliceEnd}, components.substring (0, components.length - 2));
        sliceBegin = sliceEnd + 1;
    }
}

sort ({begin: 0, end: PALETTE.length}, PALETTE_ORDER);
if (DEBUG) {
    for (paletteColor of PALETTE) {
        console.log (color.rgbaR (paletteColor) + " " + color.rgbaG (paletteColor) + " " + color.rgbaB (paletteColor) + " " + color.rgbaA (paletteColor));
    }
}
for (paletteIndex in PALETTE) {
    palette.set (paletteIndex, PALETTE [paletteIndex]);
}

},{"./lib/hsl.mjs":1,"./lib/rgb.mjs":2}]},{},[3]);
